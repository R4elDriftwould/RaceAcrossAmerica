@page "/"
@inject ApplicationDbContext DbContext


@if (activeRace != null)
{
    <FluentCard>
        <h4>@activeRace.Name</h4>

        <div style="margin-bottom: 1rem; display: flex; align-items: flex-end; gap: 1rem;">
            <div>
            <FluentLabel>Select Student:</FluentLabel>
            <FluentSelect TOption="Student"
                          Items="@allStudents"
                          OptionValue="@(p => p.StudentId.ToString())"
                          OptionText="@(p => p.Name)"
                          @bind-Value="@selectedStudentString"
                          @bind-Value:after="SelectedStudentChanged" />
            </div>
            <FluentButton Appearance="Appearance.Stealth" @onclick="ClearStudentSelection">
                Show All
            </FluentButton>
        </div>

        
        
        <div style="position: relative;">
            <img src="/images/us_map.png" style="width: 100%;" />

            <svg style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5;">

                @{
                    var orderedCheckpoints = activeRace.Checkpoints.OrderBy(c => c.CumulativeMiles).ToList();
                    for (int i = 0; i < orderedCheckpoints.Count - 1; i++)
                    {
                        var cp1 = orderedCheckpoints[i];
                        var cp2 = orderedCheckpoints[i + 1];
                        <line x1="@(cp1.X)%" y1="@(cp1.Y)%"
                              x2="@(cp2.X)%" y2="@(cp2.Y)%" class="race-route-line" />
                    }
                }

                @if (selectedStudent != null)
                {
                    var studentMiles = selectedStudent.LapsRun * 50;
                    // GetStudentPath should return the points IN ORDER, including the start and the final interpolated position
                    var studentPathPoints = GetStudentPath(studentMiles);

                    // Draw line segments between consecutive points in the student's path
                    for (int i = 0; i < studentPathPoints.Count - 1; i++)
                    {
                        var p1 = studentPathPoints[i];
                        var p2 = studentPathPoints[i + 1];

                        // Ensure coordinates are valid before drawing the line segment
                        if (p1.X >= 0 && p1.Y >= 0 && p2.X >= 0 && p2.Y >= 0)
                        {
                            <line x1="@(p1.X)%" y1="@(p1.Y)%"
                                  x2="@(p2.X)%" y2="@(p2.Y)%"
                                  class="student-progress-line" />
                        }
                    }
                }
            </svg>

            @foreach (var cp in activeRace.Checkpoints)
            {
                <div class="checkpoint-pin" 
                     style="left: @(cp.X)%; top: @(cp.Y)%; z-index: 10;"
                     @onclick="() => SelectCheckpoint(cp)"> <FluentTooltip AnchorId="@($"pin-{cp.CheckpointId}")" Delay="0">
                        @cp.City, @cp.State (@cp.CumulativeMiles mi)
                    </FluentTooltip>
                    <div id="@($"pin-{cp.CheckpointId}")"></div>
                </div>
            }

            @* --- ADD THIS NEW BLOCK for the Student Hover Popup --- *@
            @if (hoveredStudent != null && selectedStudent == null) // Show only on hover AND in "Show All" mode
            {
                var hoverMiles = hoveredStudent.LapsRun * 50;
                var (hoverX, hoverY) = GetStudentInterpolatedPosition(hoverMiles);

                // Basic popup similar to checkpoint popup
                <div class="student-hover-popup" style="left: @(hoverX)%; top: @(hoverY)%; z-index: 25;">
                    @* Higher z-index *@
                    <div class="popup-header">
                        <strong>@hoveredStudent.Name</strong>
                        @* No close button needed, disappears on mouseleave *@
                    </div>
                    <div class="popup-body">
                        <p>@hoverMiles miles</p>
                        <small>(Click pin to select)</small>
                    </div>
                </div>
            }
            @* --- END of Student Hover Popup Block --- *@

            @if (allStudents != null) // Ensure students are loaded
            {
                if (selectedStudent != null)
                {
                    // --- RENDER ONLY THE SELECTED STUDENT ---
                    var studentMiles = selectedStudent.LapsRun * 50;
                    var currentLocation = GetCurrentLocation(studentMiles);
                    var (studentX, studentY) = GetStudentInterpolatedPosition(studentMiles);

                    @if (studentX >= 0) // Check if position is valid
                    {
                        <div class="student-pin" style="left: @(studentX)%; top: @(studentY)%; z-index: 10;">
                            <FluentTooltip AnchorId="@($"student-pin-{selectedStudent.StudentId}")" Delay="0">
                                @selectedStudent.Name: @studentMiles miles (@currentLocation)
                            </FluentTooltip>
                            <div id="@($"student-pin-{selectedStudent.StudentId}")"></div>
                        </div>
                    }
                }
                else
                {
                    // --- RENDER ALL STUDENTS (NO STUDENT SELECTED) ---
                    foreach (var student in allStudents)
                    {
                        var studentMiles = student.LapsRun * 50;
                        var currentLocation = GetCurrentLocation(studentMiles);
                        var (studentX, studentY) = GetStudentInterpolatedPosition(studentMiles);

                        @if (studentX >= 0) // Check if position is valid
                        {
                            // --- ADD @onmouseenter, @onmouseleave, @onclick ---
                            <div class="student-pin"
                                 style="left: @(studentX)%; top: @(studentY)%; z-index: 10;"
                                 @onmouseenter="() => StudentPinMouseEnter(student)"
                                 @onmouseleave="StudentPinMouseLeave"
                                 @onclick="() => SelectStudentFromPin(student)">
                                 @* Use the existing FluentTooltip for accessibility/fallback *@
                                <FluentTooltip AnchorId="@($"student-pin-{student.StudentId}")" Delay="0">
                                    @student.Name: @studentMiles miles (@currentLocation)
                                </FluentTooltip>
                                <div id="@($"student-pin-{student.StudentId}")"></div>
                            </div>
                        }
                    }
                }
            }
            @if (selectedCheckpoint != null)
            {
                <div class="checkpoint-popup" style="left: @(selectedCheckpoint.X)%; top: @(selectedCheckpoint.Y)%; z-index: 20;">
                    <div class="popup-header">
                        <strong>@selectedCheckpoint.City</strong>
                        <button class="close-btn" @onclick="() => selectedCheckpoint = null">×</button>
                    </div>
                    <div class="popup-body">
                        @if (studentsAtCheckpoint.Any())
                        {
                            <ul>
                                @foreach (var s in studentsAtCheckpoint)
                                {
                                    <li>@s.Name (@(s.LapsRun * 50) mi)</li>
                                }
                            </ul>
                        }
                        else
                        {
                            <p>No students are here.</p>
                        }
                    </div>
                </div>
            }
        </div>
    </FluentCard>
}


@if (allStudents == null)
{
    <p><em>Loading student progress...</em></p>
}
else
{
    <FluentCard>
        <h3>Student Progress</h3>

        <FluentDataGrid TGridItem="Student" Items="@allStudents.AsQueryable()" GridTemplateColumns="2fr 1fr 1fr 2fr 150px">
            <TemplateColumn Title="Student Name">
                @context.Name
            </TemplateColumn>
            <TemplateColumn Title="Laps Run">
                @context.LapsRun
            </TemplateColumn>
            <TemplateColumn Title="Total Miles">
                @{
                    // We do this in a code block to re-use the variable
                    var totalMiles = context.LapsRun * 50;
                }
                @totalMiles miles
            </TemplateColumn>

            <TemplateColumn Title="Current Location">
                @GetCurrentLocation(context.LapsRun * 50)
            </TemplateColumn>

            <TemplateColumn Title="Update Laps">
                <div style="display: flex; gap: 5px;">
                    <FluentButton Appearance="Appearance.Accent" @onclick="() => AddLap(context)">
                        +1 Lap
                    </FluentButton>

                    <FluentButton Appearance="Appearance.Stealth" @onclick="() => SubtractLap(context)">
                        -1 Lap
                    </FluentButton>
                </div>
            </TemplateColumn>

        </FluentDataGrid>
    </FluentCard>
}


@code {
    private List<Student> allStudents;
    private Race activeRace; // <-- ADD THIS
    private Student selectedStudent;

    private string selectedStudentString;
    private Checkpoint selectedCheckpoint; // <-- ADD THIS
    private List<Student> studentsAtCheckpoint = new List<Student>(); // <-- ADD THIS


    protected override async Task OnInitializedAsync()
    {
        await LoadStudents();
        await LoadRace();

        if (allStudents != null && allStudents.Any())
        {
            selectedStudent = allStudents.First();
            selectedStudentString = selectedStudent.StudentId.ToString(); // <-- ADD THIS LINE
        }
    }

    private async Task LoadStudents()
    {
        allStudents = await DbContext.Students.ToListAsync();
    }

    // --- ADD THIS NEW METHOD ---
    private async Task LoadRace()
    {
        // Load the first race in the database AND its checkpoints
        // We sort by ID to get a predictable "first" race.
        activeRace = await DbContext.Races
            .Include(r => r.Checkpoints)
            .OrderBy(r => r.RaceId)
            .FirstOrDefaultAsync();
    }

    private async Task AddLap(Student studentToUpdate)
    {
        studentToUpdate.LapsRun++;
        DbContext.Students.Update(studentToUpdate);
        await DbContext.SaveChangesAsync();
        await LoadStudents();
    }

    private async Task SubtractLap(Student studentToUpdate)
    {
        // Add a check to prevent going below 0
        if (studentToUpdate.LapsRun > 0)
        {
            // 1. Decrement the lap count
            studentToUpdate.LapsRun--;

            // 2. Tell EF Core this object has changed
            DbContext.Students.Update(studentToUpdate);

            // 3. Save the change
            await DbContext.SaveChangesAsync();

            // 4. Refresh the grid
            await LoadStudents();
        }
    }

    // --- ADD THIS HELPER METHOD ---
    private string GetCurrentLocation(int studentMiles)
    {
        if (activeRace == null || !activeRace.Checkpoints.Any())
        {
            return "No race loaded";
        }

        // Find the "farthest" checkpoint the student has reached
        // We order by miles descending, and find the first one
        // that is less than or equal to the student's total miles.
        var lastCheckpoint = activeRace.Checkpoints
            .Where(c => c.CumulativeMiles <= studentMiles)
            .OrderByDescending(c => c.CumulativeMiles)
            .FirstOrDefault();

        if (lastCheckpoint == null)
        {
            return "Not started";
        }

        return $"{lastCheckpoint.City}, {lastCheckpoint.State}";
    }

    // --- ADD THIS NEW HELPER METHOD ---
    private Checkpoint GetCurrentCheckpointForStudent(int studentMiles)
    {
        if (activeRace == null || !activeRace.Checkpoints.Any())
        {
            return null;
        }

        // Same logic as GetCurrentLocation, but returns the Checkpoint object
        var lastCheckpoint = activeRace.Checkpoints
            .Where(c => c.CumulativeMiles <= studentMiles)
            .OrderByDescending(c => c.CumulativeMiles)
            .FirstOrDefault();

        // If no checkpoint is reached, return the starting checkpoint (if available)
        // Or null if no starting checkpoint (0 miles) exists
        if (lastCheckpoint == null && activeRace.Checkpoints.Any(c => c.CumulativeMiles == 0))
        {
            return activeRace.Checkpoints.FirstOrDefault(c => c.CumulativeMiles == 0);
        }

        return lastCheckpoint;
    }

    // --- ADD THIS NEW METHOD ---
    private Checkpoint GetNextCheckpoint(int studentMiles)
    {
        if (activeRace == null) return null;

        // Find the first checkpoint whose miles are GREATER than the student's
        return activeRace.Checkpoints
            .Where(c => c.CumulativeMiles > studentMiles)
            .OrderBy(c => c.CumulativeMiles)
            .FirstOrDefault();
    }

    // --- ADD THIS NEW METHOD ---
    private (double X, double Y) GetStudentInterpolatedPosition(int studentMiles)
    {
        var lastCp = GetCurrentCheckpointForStudent(studentMiles);
        if (lastCp == null)
        {
            // Not on the map yet
            return (-100, -100);
        }

        var nextCp = GetNextCheckpoint(studentMiles);
        if (nextCp == null)
        {
            // They have finished or are at the last checkpoint
            return (lastCp.X, lastCp.Y);
        }

        // --- The Interpolation Math ---
        // 1. How many miles are between these two checkpoints?
        double segmentTotalMiles = nextCp.CumulativeMiles - lastCp.CumulativeMiles;
        if (segmentTotalMiles <= 0)
        {
            return (lastCp.X, lastCp.Y); // Avoid divide-by-zero
        }

        // 2. How many miles has the student traveled *within* this segment?
        double milesIntoSegment = studentMiles - lastCp.CumulativeMiles;

        // 3. What is their progress percentage?
        double progressPercent = milesIntoSegment / segmentTotalMiles;

        // 4. Calculate the X and Y coordinates
        double newX = lastCp.X + (nextCp.X - lastCp.X) * progressPercent;
        double newY = lastCp.Y + (nextCp.Y - lastCp.Y) * progressPercent;

        return (newX, newY);
    }

    private List<(double X, double Y)> GetStudentPath(int studentMiles)
    {
        var pathPoints = new List<(double X, double Y)>();
        // Ensure race and checkpoints are loaded
        if (activeRace == null || !activeRace.Checkpoints.Any())
        {
            return pathPoints; // Return empty list if no race/checkpoints
        }

        // Get all checkpoints the student has reached or passed, ordered by miles
        var reachedOrPassedCheckpoints = activeRace.Checkpoints
            .Where(c => c.CumulativeMiles <= studentMiles)
            .OrderBy(c => c.CumulativeMiles)
            .ToList();

        // Get the effective starting point (checkpoint with 0 miles)
        var startCp = activeRace.Checkpoints.FirstOrDefault(c => c.CumulativeMiles == 0);

        if (!reachedOrPassedCheckpoints.Any())
        {
            // Student hasn't reached the first checkpoint after startCp
            if (startCp != null && studentMiles > 0)
            {
                // If they've started (miles > 0) but haven't reached CP1, draw line from startCp to current pos
                pathPoints.Add((startCp.X, startCp.Y)); // Add start point
                var (currentX, currentY) = GetStudentInterpolatedPosition(studentMiles); // Get current position
                // Add current position only if it's valid (on the map)
                if (currentX >= 0 && currentY >= 0)
                {
                    pathPoints.Add((currentX, currentY)); // Add interpolated point
                }
            }
            else if (startCp != null)
            {
                // Exactly at the start (miles = 0), add just the start point.
                pathPoints.Add((startCp.X, startCp.Y)); // Add start point
                                                        // A line won't draw yet as there's only one point.
            }
            // else: No start checkpoint defined, or miles = 0 with no startCp. Path remains empty.
        }
        else
        {
            // Student has reached or passed at least one checkpoint (could be just the startCp if miles=0)
            // Add all reached/passed checkpoints to the path
            foreach (var cp in reachedOrPassedCheckpoints)
            {
                pathPoints.Add((cp.X, cp.Y));
            }

            // Calculate the current interpolated position
            var (currentX, currentY) = GetStudentInterpolatedPosition(studentMiles);
            var lastAddedCp = reachedOrPassedCheckpoints.Last(); // Get the last checkpoint they fully passed

            // Check if the race has a defined final checkpoint
            var finalCheckpoint = activeRace.Checkpoints.OrderByDescending(c => c.CumulativeMiles).FirstOrDefault();
            bool isAtVeryEndOfRace = finalCheckpoint != null &&
                                     lastAddedCp.CheckpointId == finalCheckpoint.CheckpointId &&
                                     studentMiles >= finalCheckpoint.CumulativeMiles; // They are at or beyond the last CP

            // Add the current interpolated position if it's valid and they are NOT exactly AT the final checkpoint
            // (because the final checkpoint itself was already added in the loop above).
            if (!isAtVeryEndOfRace && currentX >= 0 && currentY >= 0)
            {
                // Only add the interpolated point if it's distinct from the last checkpoint added,
                // avoids adding duplicate point if student is exactly at an intermediate checkpoint.
                // Using a small tolerance for floating-point comparison.
                if (Math.Abs(currentX - lastAddedCp.X) > 0.01 || Math.Abs(currentY - lastAddedCp.Y) > 0.01)
                {
                    pathPoints.Add((currentX, currentY)); // Add interpolated point
                }
            }
            // If they are exactly at the end, the path already includes the final checkpoint from the loop.
        }

        return pathPoints; // Return the list of points
    }

    private void SelectCheckpoint(Checkpoint checkpoint)
    {
        selectedCheckpoint = checkpoint;
        studentsAtCheckpoint.Clear(); // Clear the old list

        var targetLocation = $"{checkpoint.City}, {checkpoint.State}";

        foreach (var student in allStudents)
        {
            var studentMiles = student.LapsRun * 50;
            var studentLocation = GetCurrentLocation(studentMiles);

            if (studentLocation == targetLocation)
            {
                studentsAtCheckpoint.Add(student);
            }
        }

        StateHasChanged();

    }

    private void ClearStudentSelection()
    {
        selectedStudent = null;
        selectedStudentString = null;
        StateHasChanged();
    }

    private void SelectedStudentChanged()
    {
        if (int.TryParse(selectedStudentString, out int studentId))
        {
            selectedStudent = allStudents.FirstOrDefault(s => s.StudentId == studentId);
        }
        else
        {
            selectedStudent = null;
        }
        // Optional: Force a UI update if needed, though usually not required
        StateHasChanged();
    }



    // Student Pin Hover and Click Functionality
    private Student hoveredStudent; // To track which student pin is hovered

    // --- NEW METHOD to handle clicking a student pin ---
    private void SelectStudentFromPin(Student studentToSelect)
    {
        if (studentToSelect != null && allStudents.Contains(studentToSelect))
        {
            selectedStudent = studentToSelect;
            selectedStudentString = studentToSelect.StudentId.ToString();
            hoveredStudent = null; // Hide hover popup once selected
            StateHasChanged(); // Update the UI
        }
    }

    // --- NEW METHODs to handle hover ---
    private void StudentPinMouseEnter(Student student)
    {
        if (selectedStudent == null) // Only show hover popup in "Show All" mode
        {
            hoveredStudent = student;
            // StateHasChanged(); // Optional: Usually not needed for hover, but add if popup doesn't appear
        }
    }

    private void StudentPinMouseLeave()
    {
        hoveredStudent = null;
        // StateHasChanged(); // Optional: Usually not needed for hover, but add if popup doesn't disappear
    }
}

<style>
    .checkpoint-pin {
        position: absolute;
        /* This creates the circle */
        width: 12px;
        height: 12px;
        background-color: #d13438; /* A nice red */
        border: 2px solid #fff;
        border-radius: 50%;
        /* This centers the pin on the X/Y coordinate */
        transform: translate(-50%, -50%);
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0,0,0,0.4);
    }

    .checkpoint-pin:hover {
        background-color: #a4262c; /* Darker red on hover */
    }

    .student-pin {
        position: absolute;
        width: 18px; /* Slightly larger */
        height: 18px;
        background-color: #0078d4; /* A nice blue */
        border: 2px solid #fff;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 2px 5px rgba(0,0,0,0.4);
        z-index: 10; /* Make sure student pins are on top of checkpoint pins */
    }

    .student-pin:hover {
        background-color: #005a9e; /* Darker blue on hover */
    }

    .race-route-line {
        stroke: #d13438; /* A red to match your pins */
        stroke-width: 3;
        stroke-dasharray: 5 5; /* Makes the line dashed */
        opacity: 0.7;
    }

    .student-progress-line {
    stroke: #0078d4;
    stroke-width: 4;
    stroke-linecap: round;
    opacity: 0.8;
    fill: none; /* -- ADD THIS to prevent weird fill-in colors */
    }

    /* === ADD ALL STYLES BELOW === */
    .checkpoint-popup {
        position: absolute;
        width: 200px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        /* This transform moves the popup to be *above* and *to the side* of the pin */
        transform: translate(-50%, -100%);
        margin-top: -15px; /* Adds a small gap above the pin */
        padding: 8px;
        font-size: 0.9rem;
    }

    .popup-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid #eee;
        padding-bottom: 5px;
        margin-bottom: 5px;
    }

    .close-btn {
        border: none;
        background: none;
        font-size: 1.5rem;
        line-height: 1;
        cursor: pointer;
        padding: 0 5px;
    }

    .popup-body ul {
        list-style-type: none;
        padding-left: 0;
        margin: 0;
    }

    .popup-body li {
        padding: 2px 0;
    }

    .popup-body p {
        margin: 0;
        padding: 5px 0;
    }

    /* --- Styles for the new Student Hover Popup --- */
    .student-hover-popup {
        position: absolute;
        width: 150px; /* Smaller than checkpoint popup */
        background-color: #f0f8ff; /* Light blue background */
        border: 1px solid #0078d4; /* Blue border */
        color: #333; /* Darker text */
        border-radius: 6px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        /* Position above and slightly to the side */
        transform: translate(-50%, -100%);
        margin-top: -15px; /* Gap above pin */
        padding: 6px;
        font-size: 0.85rem;
        pointer-events: none; /* Prevent popup from interfering with clicking the pin underneath */
    }

        .student-hover-popup .popup-header {
            border-bottom: 1px solid #cce0ff; /* Lighter blue border */
            padding-bottom: 4px;
            margin-bottom: 4px;
            justify-content: center; /* Center name */
        }

        .student-hover-popup .popup-body p,
        .student-hover-popup .popup-body small {
            margin: 0;
            padding: 1px 0;
            text-align: center;
        }

        .student-hover-popup .popup-body small {
            font-size: 0.75rem;
            color: #555;
        }
    /* --- End of Student Hover Popup Styles --- */
</style>